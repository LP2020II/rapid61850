# Rapid-prototyping protection schemes with IEC 61850 #

The goal of this software is to automatically generate C/C++ code which reads and writes GOOSE and Sampled Value packets. Any valid IEC 61850 Substation Configuration Description (SCD) file, describing GOOSE and/or SV communications, can be used as the input. The output code is lightweight and platform-independent, so it can run on a variety of devices, including low-cost microcontrollers. It's ideal for rapid-prototyping new power system protection and control systems that require communications. But the software could also be used to implement the communications for any general purpose system.

This readme file describes how to set up the software, and its basic use.

*The code is meant to be a proof of concept, and is highly experimental. It has not been tested on many SCD files. The code is also still in development at the moment, so some features may be broken or incomplete.*

<img style="float:right" src="http://personal.strath.ac.uk/steven.m.blair/mbed-cropped-small.jpg" />

## Features ##

 - Implements sending and receiving GOOSE and Sampled Value packets
 - Lightweight, and suitable for low-cost microcontrollers
 - Platform-independent, and any C/C++ compiler should work
 - Performs validation of the SCD file, and reports any problems
 - Can optionally support fixed-length GOOSE encoding, which reduces GOOSE encoding time by approximately 25-50%
 - Supports initialisation of data type values, and instance-specific values
 - The platform be used in two ways:
   - As part of a native C/C++ program. This approach would be used for embedded applications, where deterministic real-time performance is important, and where the the network interface is custom (such as on a microcontroller). It also works well with the Qt C++ GUI framework.
   - As part of a Python or Java program. This approach uses additional C code (with winpcap/libpcap) to handle the communications and data model, with [SWIG](http://www.swig.org) wrappers to link to a Python or Java program. It is useful for any application where sub-millisecond performance is not needed, because it offers the comfort and convenience of writing your control logic code in a high-level language.
 - Open source, under the GPL 2 license

## Installation ##

The software requires Eclipse, with the Eclipse Modeling Framework (EMF). Java Emitter Templates (JET) is needed for development, but not to run the code. It's easiest to start with the version of Eclipse that comes with the Modeling Tools bundle (see here: http://www.eclipse.org/downloads/). (If you are planning on using the Python or Java interfaces on Windows, it is best to use the 32-bit versions of Eclipse, and the JDK.)

There are two source code trees: `emf` (in Java), and `c` (obviously written in C). Each should be a separate project in Eclipse. The Java `emf` project directory is organised as follows:

 - `src/`
   - `scdCodeGenerator/`: code that does the bulk of the conversion from an SCD file to C code. The class `Main` contains the `main()` function for the project, and contains the filename for the input SCD file.
   - `scdCodeGeneratorTemplates/`: template classes that are generated by JET.
   - `ch/`: the EMF Java model implementation. These files are all automatically generated by EMF, but are included in the repo for convenience.
 - `model/`: the IEC 61850 XML Schema files. EMF uses these to generate the model.
 - `templates/`: the template source files used by JET.

### EMF import process ###

<!--
Note that the SCL model has been augmented to help with code generation, so the original IEC 61850 XML Schema files are not used to generate the model. Instead, the augmented model is defined in `scl.ecore`.

 1. Create an "EMF Project" called "emf", at the location of the repository code.
 2. Select "Ecore model" as the Model Importer type.
 3. Select `scl.ecore` from the File System as the model URI.
 4. Select `scl` as the root package to import.
 5. Create a new project of type "Convert Projects to JET Projects", and select the `emf` project. For the `emf` project, go to Project Properties > JET Settings, and set Template Containers to "templates", and Source Container to "src". Delete the `scdCodeGeneratorTemplates` directory in the root of `emf` that was created before JET was configured correctly.
 6. Open `SCL.genmodel` and right-click on the root of the model tree. Select "Show Properties View" and ensure that "Compliance Level" is set to "6.0". Right-click on the root again and select "Generate Model Code". This should re-generate the model implementation files, and set up the project properly for using the generated code.
-->

 1. Create an "EMF Project" called "emf", at the location of the repository code.
 2. Select "XML Schema" as the Model Importer type. Select all the IEC 61850 XML Schema documents in the `emf/model` directory.
 3. Select the three root packages that are imported (although, only `scl` is used). Click "Finish". This will re-generate some files in `emf/model`: scl.ecore, lcoordinates.ecore, lmaintenance.ecore, and SCL.genmodel.
 4. Create a new project of type "Convert Projects to JET Projects", and select the `emf` project. For the `emf` project, go to Project Properties > JET Settings, and set Template Containers to "templates", and Source Container to "src". Delete the `scdCodeGeneratorTemplates` directory in the root of `emf` that was created before JET was configured correctly.
 5. Open `SCL.genmodel` and right-click on the root of the model tree. Select "Show Properties View" and ensure that "Compliance Level" is set to "6.0". Right-click on the root again and select "Generate Model Code". This should re-generate the model implementation files (in the `emf/src/ch` directory), and set up the project properly for using the generated code.
 6. The package `org.eclipse.em.query` needs to be added to the project's Plug-in Dependencies. This can be done from the mouse cursor tooltip for the compiler error at the `import` statements.
 7. You may need to include an additional JAR library for the project to compile. In the Project Properties for `emf`, go to Java Build Path > Libraries. Click on "Add External JARs..." and find `com.ibm.icu_4.2.1.v20100412.jar` (or a similar version). It should be located in the "plugins" directory within the Eclipse installation.


### C code project example ###

An example SCD file and a `main.c` file are provided. Many of the other C files are generated automatically. For the C code to compile with Eclipse on Windows, you should:

 - Install MinGW and add `C:\MinGW\bin;` to `PATH` in the Project Properties > C/C++ Build > Environment options. (Other compilers should work too.)
 - In Project Properties > C/C++ Build > Settings > GCC Compiler Includes, set `"${workspace_loc:/${ProjName}/Include}"` as an include path.
 - In Project Properties > C/C++ Build > Settings > MinGW C Linker, add `wpcap` and `ws2_32` (assuming you are using Windows) to "Libraries" and add `"${workspace_loc:/${ProjName}/Lib}"` and `"C:\MinGW\lib"` to "Library search path".
 - The WinPcap library files and header files (from http://www.winpcap.org/devel.htm) have been included in the repository for convenience. The PC must also have the WinPcap driver installed (either by installing Wireshark, or from http://www.winpcap.org/install/default.htm).


## Using the code with a new SCD file ##

First, open the file `Main.java`. In the `Main` class, set the value of `SCD_FILENAME` to the filename of the SCD file. The SCD file should be in the same directory as the `Main.java` file. Run the Java project to generate the C implementation. **If the SCD parser complains, ensure that the first two lines of the SCD file exactly match those from the example `scd.xml` in the repository.**

A basic C `main()` function will look something like:

```C
#include "iec61850.h"

int length = 0;
unsigned char buffer[2048] = {0};

int main() {
	initialise_iec61850();											// initialise all data structures

	// send GOOSE packet
	E1Q1SB1.S1.C1.TVTRa_1.Vol.instMag.f = 1.024;					// set a value that appears in the dataset used by the "ItlPositions" GOOSE Control
	length = E1Q1SB1.S1.C1.LN0.ItlPositions.send(buffer, 1, 512);	// generate a goose packet, and store the bytes in "buffer"
	send_ethernet_packet(buffer, length);							// platform-specific call to send an Ethernet packet


	// in another IED...


	// receive GOOSE or SV packet
	length = recv_ethernet_packet(buffer);							// platform-specific call to receive an Ethernet packet
	gse_sv_packet_filter(buffer, length);							// deals with any GOOSE or SV dataset that is able to be processed

	// read value that was updated by the packet (it will equal 1.024)
	float inputValue = D1Q1SB4.S1.C1.RSYNa_1.gse_inputs_ItlPositions.E1Q1SB1_C1_Positions.C1_TVTR_1_Vol_instMag.f;

	return 0;
}
```

The data structures used for generating GOOSE and SV packets are stored within `LN0`. GOOSE packets are generated by calling the appropriate `send(buffer, statusChange, timeAllowedToLive)` function, where `statusChange` should be `1` if any value in the dataset has changed, and where `timeAllowedToLive` is the time in milliseconds for the receiver to wait for the next re-transmission. SV packets are sent by calling the `update(buffer)` function, which returns `0` if the next ASDU was written, but other ASDUs are free. It returns the size of the packet when all ASDUs have been written (and `buffer` contains the packet data). Clearly, a real implementation might include the use of platform-specific timers, interrupts and callbacks, where needed.

The generated C code implements all IEDs specified in the SCD file. You can use the code to emulate the communications between several IEDs, or just use one IED's implementation.

### Callbacks after a dataset is decoded ###

Callbacks should be set up in the form:

```C
void SVcallbackFunction(CTYPE_INT16U smpCnt) {
	;
}

void GSEcallbackFunction(CTYPE_INT32U timeAllowedToLive, CTYPE_TIMESTAMP T, CTYPE_INT32U stNum, CTYPE_INT32U sqNum) {
	;
}

//...

D1Q1SB4.S1.C1.exampleMMXU_1.sv_inputs_rmxuCB.datasetDecodeDone = &SVcallbackFunction;
D1Q1SB4.S1.C1.RSYNa_1.gse_inputs_ItlPositions.datasetDecodeDone = &GSEcallbackFunction;
```

where `D1Q1SB4.S1.C1.exampleMMXU_1` is a Logical Node defined in `datatypes.h` (and `ied.h`). `rmxuCB` is the name of the `SampledValueControl`, in a different IED, which sent the SV packets. After being initialised, the callback function will be executed after this dataset is successfully decoded, to allow the LN to deal with the new data. For example, by default, only one packet of data is saved for each GSE or SV Control - and is overwritten when a new packet arrives. Therefore, it may be useful to use the callback to log the data to a separate memory buffer.

### Fixed-length GOOSE encoding ###

To enable fixed-length GOOSE encoding, in `ctypes.h` set the value of `GOOSE_FIXED_SIZE` to `1`. Otherwise, it should have a value of `0`. This can only be enabled globally for all GOOSE encoding, rather than on a per Control basis.

### Platform-specific options ###

All platform-specific options can be edited in `ctypes.h` or `ctypes.c`. For example, for a big endian platform, change:

```C
#define LITTLE_ENDIAN		1
```

to:

```C
#define LITTLE_ENDIAN		0
```

All `CTYPE_*` definitions must map to local datatypes of the correct size and sign.

In `ctypes.c`, the basic library function `memcpy()` is used to copy bytes in order (according to platform endianness), and `reversememcpy()` copies the bytes of multi-byte data types in reverse order (for converting between endianness). Although these should work, they can be replaced with platform-specific alternatives for better performance.

The value of `TIMESTAMP_SUPPORTED` should be set to `0`, unless generating timestamps has been implemented for your platform. An implementation for Windows has been included by default.

## Using the Python or Java interfaces ##

So far, this readme has described how to use the native C/C++ interface. It's also possible to use [SWIG](http://www.swig.org/) to automatically generate wrappers for high-level languages from C/C++ header files. At the moment, Python and Java interfaces on Windows and Linux have been tested, but other languages (such as C#, Lua, Perl, Ruby, etc.) should work too.

Four C files, with filenames `interface*`, are generated along with the rest of the GOOSE/SV code. These files, and the SWIG interface file `rapid61850.i`, are used as the input to SWIG. They contain functions to start a (platform-dependent) network interface using winpcap/libpcap, and functions to send GOOSE or SV packets using that network interface. All of the interaction with pcap is done in C, and is hidden by the interface given to SWIG. Note that this interface can also be used within a C/C++ application.

### Building on Windows ###

If using MinGW as the C compiler (as described above), this process is significantly simpler with the 32-bit versions of Eclipse and the JDK are used. The following instructions assume this. It's also assumed that the Java or Python application exists within a directory at the same level as the `emf` and `c` directories.

 - Generate the C code for your SCD file, as described above.
 - [Download](http://www.swig.org/download.html) `swigwin`, which is a pre-compiled binary of SWIG for Windows. Once unzipped, there are two options for using this:
   - Add the location of `swig.exe` to the Windows `PATH` environment variable.
   - Or, copy the contents of the swigwin directory (i.e., copy `swig.exe` *and* all the sub-folders) to the `c/src` directory.
 - Create the directory for your Python or Java program called, for example, `python_interface` or `java_interface`. You may wish to make this an Eclipse PyDev or Java project.
 - Open a command prompt at the `c/src` directory, and run SWIG using one of the following commands:

    For Python:
    swig -python -outdir ..\..\python_interface rapid61850.i

	For Java:
    swig -java -outdir ..\..\java_interface rapid61850.i

Now we need to change the compiler settings for the `c` project to generate a dynamic library, instead of an executable. This differs for Python and Java. It may be helpful to create different build configurations in Eclipse if you need to use more than one of the C/C++, Python, or Java interfaces.

#### Python C compiler settings ####

 - In C/C++ Build > Settings > Build Artifact:
   - set Artifact Type to `Shared Library`
   - set Artifact name to `rapid61850`
   - set Artifact extension to `pyd`
   - set Output prefix to `_`
 - In C/C++ Build > Settings > Tool Settings > Includes, use the following Include Paths (**adjust these to match the exact version and location of Python on your system**):
   - "C:\Python27"
   - "C:\Python27\include"
   - "C:\Python27\Lib"
   - "${workspace_loc:/${ProjName}/Include}"
 - In C/C++ Build > Settings > Tool Settings > Libraries, use the following Libraries (-l):
   - `wpcap`, `python27`, and `ws2_32`. (Again, adjust `python27` to the correct version.)
 - In C/C++ Build > Settings > Tool Settings > Libraries, use the following Libraries search paths (-L):
   - "${workspace_loc:/${ProjName}/Lib}"
   - "C:\Python27\libs"
 - Build the C project, and copy the `_rapid61850.pyd` file from the Release folder to the `python_interface` project directory.
 - Create and run your Python code, e.g.:

    ```python
    import rapid61850
    from rapid61850 import *

    rapid61850.start()

    rapid61850.gse_send_D1Q1SB4_C1_MMXUResult_buf(1, 512);    # send GOOSE packet

    rapid61850.cvar.E1Q1SB1.S1.C1.LPHDa_1.Mod.stVal = MOD_ON  # interact with IED data model
    print rapid61850.cvar.E1Q1SB1.S1.C1.LPHDa_1.Mod.stVal
    ```

    Note that all C global variables appear within `rapid61850.cvar`.

#### Java C compiler settings ####

 - In C/C++ Build > Settings > Build Artifact:
   - set Artifact Type to `Shared Library`
   - set Artifact name to `rapid61850`
   - set Artifact extension to `dll`
   - set Output prefix to ``
 - In C/C++ Build > Settings > Tool Settings > Includes, use the following Include Paths (**adjust these to match the exact version and location of Python on your system**):
   - "C:\Program Files (x86)\Java\jdk1.7.0_03\include"
   - "C:\Program Files (x86)\Java\jdk1.7.0_03\include\win32"
   - "${workspace_loc:/${ProjName}/Include}"
 - In C/C++ Build > Settings > Tool Settings > Libraries, use the following Library search path (-L):
   - "${workspace_loc:/${ProjName}/Lib}"
 - Build the C project, and copy the `rapid61850.dll` file from the Release folder to the `java_interface` project directory.
 - Create your Java code, e.g.:

    ```java
    public class Main {
        static {
            System.loadLibrary("rapid61850");
        }

        public static void main(String[] args) {
            rapid61850.start();

            System.out.println(rapid61850.gse_send_E1Q1SB1_C1_Performance_buf(1, 512));                     // send GOOSE packet
    
            rapid61850.getE1Q1SB1().getS1().getC1().getMMXUa_1().getMod().setStVal(Mod.MOD_ON);             // interact with IED data model
            System.out.println(rapid61850.getE1Q1SB1().getS1().getC1().getMMXUa_1().getMod().getStVal());
        }
    }
    ```
 - To run the Java program, you first need to specify the path to the native library. In Project Properties > Java Build Path > Libraries, expand the "JRE System Library" tree and select "Native library location". Click on "Edit..." and enter the project name (e.g., `java_interface`) as the Location path.


### Building on Linux ###

Coming soon...

## Known issues and possible features ##

 - Several data types are not yet supported. However, the main *useful* data types (integer, floating-point, and boolean) are supported.
 - FCDAs and ExtRefs cannot use the syntax "vector.mag.f" as values for data object or data attribute references.
 - Data types cannot contain arrays.
 - According to [the standard](http://www.tissues.iec61850.com/tissue.mspx?issueid=579), SV datasets should only contain primitive data types, and not constructed types. However, because SV encoding involves fixed-length value fields, it is always possible to reconstruct the data, if encoded and decoded consistently. Therefore, this library will allow constructed types to be encoded in SV packets.
 - Does not find ExtRef DA satisfied by container DO within a dataset, where the DA is not explicitly in a dataset.
 - The Python and Java interfaces need code for receiving packets.
