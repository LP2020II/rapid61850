<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>rapid61850 by stevenblair</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>rapid61850</h1>
        <p>Rapid-prototyping protection and control schemes with IEC 61850</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/stevenblair/rapid61850" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/stevenblair/rapid61850/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/stevenblair/rapid61850/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>Rapid-prototyping protection schemes with IEC 61850</h1>

<p>The goal of this software is to automatically generate C/C++ code which reads and writes GOOSE and Sampled Value packets. Any valid IEC 61850 Substation Configuration Description (SCD) file, describing GOOSE and/or SV communications, can be used as the input. The output code is lightweight and platform-independent, so it can run on a variety of devices, including low-cost microcontrollers and the Raspberry Pi. It's ideal for rapid-prototyping new power system protection, control, and automation systems that require communications.</p>

<p>This readme file describes how to set up the software, and its basic use.</p>

<p><em>The code is meant to be a proof of concept, and is highly experimental. It has not been tested on many SCD files. Some features may be incomplete.</em></p>

<p><img src="http://personal.strath.ac.uk/steven.m.blair/mbed-cropped.png"></p>

<h2>Features</h2>

<ul>
<li>Implements sending and receiving GOOSE and Sampled Value packets</li>
<li>Lightweight and fast, and suitable for low-cost microcontrollers and the Raspberry Pi</li>
<li>Platform-independent, and any C/C++ compiler should work</li>
<li>Performs validation of the SCD file, and reports any problems</li>
<li>Can optionally support fixed-length GOOSE encoding, which reduces GOOSE encoding time by approximately 50%</li>
<li>Supports initialisation of data type values, and instance-specific values</li>
<li>Simple API. The platform can be used in two ways:

<ul>
<li>As part of a native C/C++ program. This approach would be used where deterministic real-time performance is important, or where the network interface is custom (such as on a microcontroller). It also works well with the Qt C++ GUI framework.</li>
<li>As part of a Python or Java program. This approach uses additional C code (with winpcap/libpcap) to automatically handle the communications and data model, with <a href="http://www.swig.org">SWIG</a> wrappers to link to a Python or Java program. All the communications is handled behind the scenes. It is useful for any application where sub-millisecond performance is not needed, because it offers the comfort and convenience of writing your control logic code in a high-level language.</li>
</ul>
</li>
<li>Open source, under the GPL 2</li>
</ul><h2>Installation</h2>

<p>This process has been tested on Windows and Ubuntu, but other Linux flavours and OS X should work too. Most steps only need to be completed once.</p>

<p>The software requires Eclipse, with the Eclipse Modeling Framework (EMF). Java Emitter Templates (JET) is needed for development, but not to run the code. It's easiest to start with the version of Eclipse that comes with the Modeling Tools bundle (see here: <a href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a>). (If you are planning on using the Python or Java interfaces on Windows, it is best to use the 32-bit versions of Eclipse, and the JDK.)</p>

<p>There are two source code trees: <code>emf</code> (in Java), and <code>c</code> (obviously written in C). Each should be a separate project in Eclipse. The Java <code>emf</code> project directory is organised as follows:</p>

<ul>
<li>
<code>src/</code>

<ul>
<li>
<code>rapid61850/</code>: code that does the bulk of the conversion from an SCD file to C code. The class <code>Main</code> contains the <code>main()</code> function for the project, and contains the filename for the input SCD file.

<ul>
<li>
<code>templates/</code>: template classes that are generated by JET.</li>
</ul>
</li>
<li>
<code>ch/</code>: the EMF Java model implementation. These files are all automatically generated by EMF, but are included in the repo for convenience.</li>
</ul>
</li>
<li>
<code>model/</code>: the IEC 61850 XML Schema files. EMF uses these to generate the model.</li>
<li>
<code>templates/</code>: the template source files used by JET.</li>
</ul><h3>EMF import process</h3>

<ol>
<li>Start Eclipse, with the Workspace set to the root of the repository directory, e.g., <code>/home/user/rapid61850</code> on Linux.</li>
<li>Create an "EMF Project" called "emf", at the location of the repository code.</li>
<li>Select "XML Schema" as the Model Importer type. Select all the IEC 61850 XML Schema documents in the <code>emf/model</code> directory.</li>
<li>Select the three root packages that are imported (although, only <code>scl</code> is used). Click "Finish". This will re-generate some files in <code>emf/model</code>: scl.ecore, lcoordinates.ecore, lmaintenance.ecore, and SCL.genmodel.</li>
<li>Create a new project of type "Convert Projects to JET Projects", and select the <code>emf</code> project. For the <code>emf</code> project, go to Project Properties &gt; JET Settings, and set Template Containers to "templates", and Source Container to "src". Delete the <code>rapid61850/templates</code> directory in the root of <code>emf</code> that was created before JET was configured correctly.</li>
<li>Open <code>SCL.genmodel</code> and right-click on the root of the model tree. Select "Show Properties View" and ensure that "Compliance Level" is set to "6.0". Right-click on the root again and select "Generate Model Code". This should re-generate the model implementation files (in the <code>emf/src/ch</code> directory), and set up the project properly for using the generated code.</li>
<li>Two additional JAR libraries must be included for the project to compile. In the Project Properties for <code>emf</code>, go to Java Build Path &gt; Libraries. Click on "Add External JARs..." and find <code>com.ibm.icu_4.4.2.v20110823.jar</code> and <code>org.eclipse.emf.query_1.2.100.v200903190031.jar</code> (or similar versions). These should be located in the "plugins" directory within the Eclipse installation.</li>
</ol><h3>C code project example</h3>

<p>An example SCD file and a <code>main.c</code> file are provided. Many of the other C files are generated automatically. For the C code to compile with Eclipse, you should:</p>

<ul>
<li>If you plan to use the native, low-level C/C++ interface (as shown in <a href="https://github.com/stevenblair/rapid61850#using-the-code-with-a-new-scd-file">the next section</a>), exclude the two <code>interface*.c</code> files from the build in Eclipse: right-click on the files &gt; "Resource Configurations" &gt; "Exclude from Build...", and then choose "Release" or "Debug" or another build. Also, exclude the <code>main_SV_LE.c</code> file, which provides an example implementation of IEC 61850-9-2LE Sampled Values, using <code>scd_LE.xml</code> as the SCD file. Otherwise, if using the high-level interfaces, exclude the existing <code>main.c</code> and <code>main_SV_LE.c</code> files.</li>
<li>Install MinGW and add <code>C:\MinGW\bin;</code> to <code>PATH</code> in the Project Properties &gt; C/C++ Build &gt; Environment options. (Other compilers should work too.)</li>
<li>In Project Properties &gt; C/C++ Build &gt; Settings &gt; GCC Compiler Includes, set <code>"${workspace_loc:/${ProjName}/Include}"</code> as an include path.</li>
<li>In Project Properties &gt; C/C++ Build &gt; Settings &gt; MinGW C Linker, add <code>wpcap</code> and <code>ws2_32</code> (assuming you are using Windows) to "Libraries" and add <code>"${workspace_loc:/${ProjName}/Lib}"</code> and <code>"C:\MinGW\lib"</code> to "Library search path".

<ul>
<li>With Linux, use <code>pcap</code> instead of <code>wpcap</code>, and just add <code>"${workspace_loc:/${ProjName}/Lib}"</code> to the  "Library search path".</li>
</ul>
</li>
<li>The WinPcap library files and header files (from <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a>) have been included in the repository for convenience. The PC must also have the WinPcap driver installed (either by installing Wireshark, or from <a href="http://www.winpcap.org/install/default.htm">http://www.winpcap.org/install/default.htm</a>).

<ul>
<li>With Ubuntu, libpcap can be installed using <code>sudo apt-get install libpcap-dev</code>.</li>
<li>Remember that, on Linux, <strong>libpcap needs to run as root</strong>, so either start Eclipse or run the compiled binary from the Terminal with <code>sudo</code>. Alternatively, you can grant the binary the <a href="http://packetlife.net/blog/2010/mar/19/sniffing-wireshark-non-root-user/">capability to access the network interface</a> using: <code>sudo setcap cap_net_raw,cap_net_admin=eip /path_to_project/rapid61850/c/Release/c</code>.</li>
</ul>
</li>
</ul><h2>Using the code with a new SCD file</h2>

<p>First, open the file <code>Main.java</code>. In the <code>Main</code> class, set the value of <code>SCD_FILENAME</code> to the filename of the SCD file. The SCD file should be in the same directory as the <code>Main.java</code> file. Run the Java project to generate the C implementation. <strong>If the SCD parser complains, ensure that the first two lines of the SCD file exactly match those from the example <code>scd.xml</code> in the repository.</strong> It's usually best to refresh the C project in Eclipse, to ensure that Eclipse knows about the new or modified files.</p>

<p>A basic C <code>main()</code> function will look something like:</p>

<div class="highlight"><pre><span class="cp">#include "iec61850.h"</span>

<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2048</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">initialise_iec61850</span><span class="p">();</span>                                         <span class="c1">// initialise all data structures</span>

    <span class="c1">// send GOOSE packet</span>
    <span class="n">E1Q1SB1</span><span class="p">.</span><span class="n">S1</span><span class="p">.</span><span class="n">C1</span><span class="p">.</span><span class="n">TVTRa_1</span><span class="p">.</span><span class="n">Vol</span><span class="p">.</span><span class="n">instMag</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="mf">1.024</span><span class="p">;</span>                   <span class="c1">// set a value that appears in the dataset used by the "ItlPositions" GOOSE Control</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">E1Q1SB1</span><span class="p">.</span><span class="n">S1</span><span class="p">.</span><span class="n">C1</span><span class="p">.</span><span class="n">LN0</span><span class="p">.</span><span class="n">ItlPositions</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>  <span class="c1">// generate a goose packet, and store the bytes in "buffer"</span>
    <span class="n">send_ethernet_packet</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>                          <span class="c1">// platform-specific call to send an Ethernet packet</span>


    <span class="c1">// in another IED...</span>


    <span class="c1">// receive GOOSE or SV packet</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">recv_ethernet_packet</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>                         <span class="c1">// platform-specific call to receive an Ethernet packet</span>
    <span class="n">gse_sv_packet_filter</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>                          <span class="c1">// deals with any GOOSE or SV dataset that is able to be processed</span>

    <span class="c1">// read value that was updated by the packet (it will equal 1.024)</span>
    <span class="kt">float</span> <span class="n">inputValue</span> <span class="o">=</span> <span class="n">D1Q1SB4</span><span class="p">.</span><span class="n">S1</span><span class="p">.</span><span class="n">C1</span><span class="p">.</span><span class="n">RSYNa_1</span><span class="p">.</span><span class="n">gse_inputs_ItlPositions</span><span class="p">.</span><span class="n">E1Q1SB1_C1_Positions</span><span class="p">.</span><span class="n">C1_TVTR_1_Vol_instMag</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The data structures used for generating GOOSE and SV packets are stored within <code>LN0</code>. GOOSE packets are generated by calling the appropriate <code>send(buffer, statusChange, timeAllowedToLive)</code> function, where <code>statusChange</code> should be <code>1</code> if any value in the dataset has changed, and where <code>timeAllowedToLive</code> is the time in milliseconds for the receiver to wait for the next re-transmission. SV packets are sent by calling the <code>update(buffer)</code> function, which returns <code>0</code> if the next ASDU was written, but other ASDUs are free. It returns the size of the packet when all ASDUs have been written (and <code>buffer</code> contains the packet data). Clearly, a real implementation might include the use of platform-specific timers, interrupts and callbacks, where needed.</p>

<p>The generated C code implements all IEDs specified in the SCD file. You can use the code to emulate the communications between several IEDs, or just use one IED's implementation.</p>

<h3>Callbacks after a dataset is decoded</h3>

<p>Callbacks should be set up in the form:</p>

<div class="highlight"><pre><span class="kt">void</span> <span class="nf">SVcallbackFunction</span><span class="p">(</span><span class="n">CTYPE_INT16U</span> <span class="n">smpCnt</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GSEcallbackFunction</span><span class="p">(</span><span class="n">CTYPE_INT32U</span> <span class="n">timeAllowedToLive</span><span class="p">,</span> <span class="n">CTYPE_TIMESTAMP</span> <span class="n">T</span><span class="p">,</span> <span class="n">CTYPE_INT32U</span> <span class="n">stNum</span><span class="p">,</span> <span class="n">CTYPE_INT32U</span> <span class="n">sqNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span>
<span class="p">}</span>

<span class="c1">//...</span>

<span class="n">D1Q1SB4</span><span class="p">.</span><span class="n">S1</span><span class="p">.</span><span class="n">C1</span><span class="p">.</span><span class="n">exampleMMXU_1</span><span class="p">.</span><span class="n">sv_inputs_rmxuCB</span><span class="p">.</span><span class="n">datasetDecodeDone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SVcallbackFunction</span><span class="p">;</span>
<span class="n">D1Q1SB4</span><span class="p">.</span><span class="n">S1</span><span class="p">.</span><span class="n">C1</span><span class="p">.</span><span class="n">RSYNa_1</span><span class="p">.</span><span class="n">gse_inputs_ItlPositions</span><span class="p">.</span><span class="n">datasetDecodeDone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">GSEcallbackFunction</span><span class="p">;</span>
</pre></div>

<p>where <code>D1Q1SB4.S1.C1.exampleMMXU_1</code> is a Logical Node defined in <code>datatypes.h</code> (and <code>ied.h</code>). <code>rmxuCB</code> is the name of the <code>SampledValueControl</code>, in a different IED, which sent the SV packets. After being initialised, the callback function will be executed after this dataset is successfully decoded, to allow the LN to deal with the new data. For example, by default, only one packet of data is saved for each GSE or SV Control - and is overwritten when a new packet arrives. Therefore, it may be useful to use the callback to log the data to a separate memory buffer.</p>

<h3>Fixed-length GOOSE encoding</h3>

<p>To enable fixed-length GOOSE encoding, in <code>ctypes.h</code> set the value of <code>GOOSE_FIXED_SIZE</code> to <code>1</code>. Otherwise, it should have a value of <code>0</code>. This can only be enabled globally for all GOOSE encoding, rather than on a per Control basis.</p>

<h3>Platform-specific options</h3>

<p>All platform-specific options can be edited in <code>ctypes.h</code> or <code>ctypes.c</code>. For example, for a big endian platform, change:</p>

<div class="highlight"><pre><span class="cp">#define LITTLE_ENDIAN       1</span>
</pre></div>

<p>to:</p>

<div class="highlight"><pre><span class="cp">#define LITTLE_ENDIAN       0</span>
</pre></div>

<p>All <code>CTYPE_*</code> definitions must map to local datatypes of the correct size and sign.</p>

<p>In <code>ctypes.c</code>, the basic library function <code>memcpy()</code> is used to copy bytes in order (according to platform endianness), and <code>reversememcpy()</code> copies the bytes of multi-byte data types in reverse order (for converting between endianness). Although these should work, they can be replaced with platform-specific alternatives for better performance.</p>

<p>The value of <code>TIMESTAMP_SUPPORTED</code> should be set to <code>0</code>, unless generating timestamps has been implemented for your platform. An implementation for Windows has been included by default.</p>

<h2>Using the Python or Java interfaces</h2>

<p>So far, this readme has described how to use the native C/C++ interface. It's also possible to use <a href="http://www.swig.org/">SWIG</a> to automatically generate wrappers for high-level languages from C/C++ header files. At the moment, Python and Java interfaces on Windows and Linux have been tested, but other languages (such as C#, Lua, Perl, Ruby, etc.) should work too. (You can also use the high-level interface from C/C++ too, but not alongside the native interface.)</p>

<p>Four C files, with filenames <code>interface*</code>, are generated along with the rest of the GOOSE/SV code. These files, and the SWIG interface file <code>rapid61850.i</code>, are used as the input to SWIG. They contain functions to start a (platform-dependent) network interface using winpcap/libpcap, and functions to send GOOSE or SV packets using that network interface. All of the interaction with pcap is done in C, and is hidden by the interface given to SWIG.</p>

<p>Note that this interface can also be used within a C/C++ application - this is shown in the example <code>main.c</code> file, if <code>HIGH_LEVEL_INTERFACE</code> is defined as <code>1</code>. If your are not using this high-level interface, and are using the plain C interface, you may need to exclude the two <code>interface*.c</code> files from the build in Eclipse.</p>

<h3>Building on Windows</h3>

<p>If using MinGW as the C compiler (as described above), this process is significantly simpler if the 32-bit versions of Eclipse and the JDK are used. The following instructions assume this. It's also assumed that the Python or Java application exists within a directory at the same level as the <code>emf</code> and <code>c</code> directories.</p>

<ul>
<li>Generate the C code for your SCD file, as described above.</li>
<li>
<a href="http://www.swig.org/download.html">Download</a> <code>swigwin</code>, which is a pre-compiled binary of SWIG for Windows. Once unzipped, there are two options for using this:

<ul>
<li>Add the location of <code>swig.exe</code> to the Windows <code>PATH</code> environment variable.</li>
<li>Or, copy the contents of the swigwin directory (i.e., copy <code>swig.exe</code> <em>and</em> all the sub-folders) to the <code>c/src</code> directory. You will need to tell Eclipse to exclude these directories from the build.</li>
</ul>
</li>
<li>Create the directory for your Python or Java program called, for example, <code>python_interface</code> or <code>java_interface</code>. You may wish to make this an Eclipse PyDev or Java project.</li>
<li>
<p>Open a command prompt at the <code>c/src</code> directory, and run SWIG using one of the following commands:</p>

<p>For Python:</p>

<pre><code>swig -python -outdir ..\..\python_interface rapid61850.i
</code></pre>

<p>For Java:</p>

<pre><code>swig -java -outdir ..\..\java_interface rapid61850.i
</code></pre>
</li>
</ul><p>The following subsections explain how to change the compiler settings for the <code>c</code> project to generate a dynamic library, instead of an executable. This differs for Python and Java. It may be helpful to create different build configurations in Eclipse if you need to use more than one of the C/C++, Python, or Java interfaces. You may also need to exclude the existing <code>main.c</code> file from any Python or Java builds.</p>

<h4>Python interface C compiler settings</h4>

<ul>
<li>In C/C++ Build &gt; Settings &gt; Build Artifact:

<ul>
<li>set Artifact Type to <code>Shared Library</code>
</li>
<li>set Artifact name to <code>rapid61850</code>
</li>
<li>set Artifact extension to <code>pyd</code>
</li>
<li>set Output prefix to <code>_</code>
</li>
</ul>
</li>
<li>In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Includes, use the following Include Paths (**adjust these to match the exact version and location of Python on your system**):

<ul>
<li><code>"C:\Python27"</code></li>
<li><code>"C:\Python27\include"</code></li>
<li><code>"C:\Python27\Lib"</code></li>
<li><code>"${workspace_loc:/${ProjName}/Include}"</code></li>
</ul>
</li>
<li>In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Libraries, use the following Libraries (-l):

<ul>
<li>
<code>wpcap</code>, <code>python27</code>, and <code>ws2_32</code>. (Again, adjust <code>python27</code> to the correct version.)</li>
</ul>
</li>
<li>In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Libraries, use the following Libraries search paths (-L):

<ul>
<li><code>"${workspace_loc:/${ProjName}/Lib}"</code></li>
<li><code>"C:\Python27\libs"</code></li>
</ul>
</li>
<li>Build the C project, and copy the <code>_rapid61850.pyd</code> file from the Release folder to the <code>python_interface</code> project directory.</li>
<li>
<p>Create and run your Python code, e.g.:</p>

<div class="highlight"><pre><span class="kn">import</span> <span class="nn">rapid61850</span>
<span class="kn">from</span> <span class="nn">rapid61850</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">rapid61850</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">rapid61850</span><span class="o">.</span><span class="n">interface_gse_send_D1Q1SB4_C1_MMXUResult</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>     <span class="c"># send GOOSE packet</span>

<span class="n">rapid61850</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">E1Q1SB1</span><span class="o">.</span><span class="n">S1</span><span class="o">.</span><span class="n">C1</span><span class="o">.</span><span class="n">LPHDa_1</span><span class="o">.</span><span class="n">Mod</span><span class="o">.</span><span class="n">stVal</span> <span class="o">=</span> <span class="n">MOD_ON</span>  <span class="c"># interact with IED data model</span>
<span class="k">print</span> <span class="n">rapid61850</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">E1Q1SB1</span><span class="o">.</span><span class="n">S1</span><span class="o">.</span><span class="n">C1</span><span class="o">.</span><span class="n">LPHDa_1</span><span class="o">.</span><span class="n">Mod</span><span class="o">.</span><span class="n">stVal</span>
</pre></div>

<p>Note that all C global variables appear within <code>rapid61850.cvar</code>.</p>
</li>
</ul><h4>Java interface C compiler settings</h4>

<ul>
<li>In C/C++ Build &gt; Settings &gt; Build Artifact:

<ul>
<li>set Artifact Type to <code>Shared Library</code>
</li>
<li>set Artifact name to <code>rapid61850</code>
</li>
<li>set Artifact extension to <code>dll</code>
</li>
<li>leave Output prefix blank</li>
</ul>
</li>
<li>In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Includes, use the following Include Paths (**adjust these to match the exact version and location of Java on your system**):

<ul>
<li><code>"C:\Program Files (x86)\Java\jdk1.7.0_03\include"</code></li>
<li><code>"C:\Program Files (x86)\Java\jdk1.7.0_03\include\win32"</code></li>
<li><code>"${workspace_loc:/${ProjName}/Include}"</code></li>
</ul>
</li>
<li>In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Libraries, use the following Library search path (-L):

<ul>
<li><code>"${workspace_loc:/${ProjName}/Lib}"</code></li>
</ul>
</li>
<li>In In C/C++ Build &gt; Settings &gt; Tool Settings &gt; Miscellaneous, add <code>-Wl,-add-stdcall-alias</code> to the Linker flags</li>
<li>Build the C project, and copy the <code>rapid61850.dll</code> file from the Release folder to the <code>java_interface</code> project directory.</li>
<li>
<p>Create your Java code, e.g.:</p>

<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"rapid61850"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rapid61850</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rapid61850</span><span class="o">.</span><span class="na">interface_gse_send_E1Q1SB1_C1_Performance</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">512</span><span class="o">));</span>                     <span class="c1">// send GOOSE packet</span>

        <span class="n">rapid61850</span><span class="o">.</span><span class="na">getE1Q1SB1</span><span class="o">().</span><span class="na">getS1</span><span class="o">().</span><span class="na">getC1</span><span class="o">().</span><span class="na">getMMXUa_1</span><span class="o">().</span><span class="na">getMod</span><span class="o">().</span><span class="na">setStVal</span><span class="o">(</span><span class="n">Mod</span><span class="o">.</span><span class="na">MOD_ON</span><span class="o">);</span>             <span class="c1">// interact with IED data model</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rapid61850</span><span class="o">.</span><span class="na">getE1Q1SB1</span><span class="o">().</span><span class="na">getS1</span><span class="o">().</span><span class="na">getC1</span><span class="o">().</span><span class="na">getMMXUa_1</span><span class="o">().</span><span class="na">getMod</span><span class="o">().</span><span class="na">getStVal</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</li>
<li><p>To run the Java program, you first need to specify the path to the native library. In Project Properties &gt; Java Build Path &gt; Libraries, expand the "JRE System Library" tree and select "Native library location". Click on "Edit..." and enter the project name (e.g., <code>java_interface</code>) as the Location path. Note that if the interface changes, such as due to changes in the SCD file, then all <code>.java</code> and <code>.class</code> files generated by SWIG should be deleted before a new dynamic library is compiled and used by the Java program.</p></li>
</ul><h3>Building on Linux</h3>

<p>On Linux, it's easier to create the Python or Java interface with the Terminal, rather than with Eclipse. The steps below assume Ubuntu (and have only been tested on 11.10 64-bit), so it may differ on other distributions.</p>

<p>Install the following packages:</p>

<div class="highlight"><pre>sudo apt-get install libpcap-dev
sudo apt-get install swig
sudo apt-get install build-essential
sudo apt-get install python2.7         <span class="c"># other Python versions should be ok</span>
sudo apt-get install openjdk-6-jdk
</pre></div>



<p>Open a Terminal at the <code>rapid61850/c/src</code> directory.</p>

<h4>Python</h4>

<div class="highlight"><pre><span class="c"># attempt to clean up any previous files</span>
rm *.o *.so *_wrap.c rapid61850.py rapid61850.pyc

<span class="c"># run SWIG, output goes in current directory</span>
swig -python rapid61850.i

<span class="c"># compile and link the C library</span>
gcc -fPIC -c *.c -I/usr/include/python2.7
gcc -shared *.o -lpcap -o _rapid61850.so

<span class="c"># run Python. sudo is needed for the network interface</span>
sudo python2.7

<span class="c"># example Python program:</span>
&gt;&gt;&gt; import rapid61850
&gt;&gt;&gt; rapid61850.start<span class="o">()</span>
&gt;&gt;&gt; print rapid61850.interface_gse_send_D1Q1SB4_C1_MMXUResult<span class="o">(</span>1, 512<span class="o">)</span>
332
&gt;&gt;&gt; <span class="nb">exit</span><span class="o">()</span>
</pre></div>

<h4>Java</h4>

<div class="highlight"><pre><span class="c"># attempt to clean up any previous files</span>
rm *.o *.so *_wrap.c java/*.class java/*.java

mkdir java    <span class="c"># only needed once</span>

<span class="c"># run SWIG, and put the .java files (there will be a lot) in the "java" sub-directory</span>
swig -java -outdir java rapid61850.i

<span class="c"># compile and link the C library</span>
gcc -fPIC -c *.c -I/usr/lib/jvm/java-6-openjdk/include -I/usr/lib/jvm/java-6-openjdk/include/linux
ld -G *.o -lpcap -o librapid61850.so

<span class="c"># compile all .java files, including the sample program</span>
javac -d java/ java/*.java ../../java_interface/Main.java

<span class="c"># run the sample Java program. sudo is needed for the network interface</span>
<span class="nb">cd </span>java
sudo java -Djava.library.path<span class="o">=</span>/home/steven/rapid61850/c/src/ Main    <span class="c"># this path must be set correctly</span>
</pre></div>

<h2>Software documentation</h2>

<h3>Validation</h3>

<p><code>SCDValidator.java</code> performs semantic validation of the SCD file, prior to code generation. It checks for the following constraints:</p>

<ul>
<li>Where necessary, the names of IEDs, logical nodes, data sets and data types are unique.</li>
<li>Each Control instance has matching DataSet and ControlBlock instances.</li>
<li>Each logical node “Input” has a corresponding source in a data set (typically in another IED).</li>
<li>No circular sub-data object (SDO) references occur.</li>
<li>Data attributes, basic data attributes and SDOs must map to valid types that exist in the SCD file.</li>
<li>Data type definitions appear in a hierarchical order, that will result in valid generated code.</li>
</ul><p>As shown in <code>Main.java</code>, the validation process is separate from the code generation process. Therefore, it's possible to reuse the validation process in other software, if needed.</p>

<p>The validation process extensively uses the <a href="http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.emf.query.doc/tutorials/queryTutorial.html">EMF Model Query</a> framework for searching and filtering SCD data. It uses a SQL-like syntax. For example, to find all IEDs in the SCD document object <code>root</code>:</p>

<div class="highlight"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkForDuplicateNames</span><span class="o">(</span><span class="n">DocumentRoot</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// describe a condition: is the object an IED (called `TIED` in EMF)?</span>
    <span class="kd">final</span> <span class="n">EObjectCondition</span> <span class="n">isIED</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EObjectTypeRelationCondition</span><span class="o">(</span>
        <span class="n">SclPackage</span><span class="o">.</span><span class="na">eINSTANCE</span><span class="o">.</span><span class="na">getTIED</span><span class="o">()</span>
    <span class="o">);</span>

    <span class="c1">// build and execute a query</span>
    <span class="n">IQueryResult</span> <span class="n">iedResult</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SELECT</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">FROM</span><span class="o">(</span><span class="n">root</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">WHERE</span><span class="o">(</span><span class="n">isIED</span><span class="o">)</span>
    <span class="o">).</span><span class="na">execute</span><span class="o">();</span>

    <span class="c1">// loop through results</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">iedResult</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TIED</span> <span class="n">ied</span> <span class="o">=</span> <span class="o">(</span><span class="n">TIED</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">iedName</span> <span class="o">=</span> <span class="n">ied</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>

        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>Augmented IEC 61850-6 SCL model</h3>

<p><code>SCDAdditionalMappings.java</code> uses hash maps to explicitly link parts of the Java representation of the SCL model. This greatly simplifies the code generation process. (In the SCL, these links are implicit and are achieved by string-matching.) Each mapping is as follows:</p>

<ul>
<li>Each DAI is mapped to an AbstractDataAttribute, which has the sub-type of either DA or BDA, which defines the type of the DAI value.</li>
<li>Each Control, which has the sub-types GSEControl and SampledValueControl, is mapped to the matching DataSet for convenience.</li>
<li>ExtRefs are mapped to all DataSets, typically in other IEDs, which satisfy the ExtRef.</li>
<li>Instances of BaseElement, which is the super-class of DO, DA, and BDA, are mapped to Strings which contain pre-calculated C code.</li>
<li>FCDAs are mapped to:

<ul>
<li>The data item to which the FCDA refers, which may be a DO, DA, or BDA (all of which are sub-classes of BaseElement). Therefore, the type of the FCDA can be inferred.</li>
<li>The LN instance which contains the source data.</li>
<li>A String which is the unique name of the FCDA used in C code generation.</li>
</ul>
</li>
</ul><h3>Code generation</h3>

<p>The following UML class diagram illustrates how a generic representation of a C file is used by the code generation process:</p>

<p><img src="http://personal.strath.ac.uk/steven.m.blair/CFile-UML.png"></p>

<p>Java Emitter Template (JET) files (<code>CSourceTemplate</code> and <code>CHeaderTemplate</code>) are used to define the generic structure of C source and header files. This approach allows several header files, which specify function prototypes, to be generated automatically from the <code>CSource</code> objects.</p>

<h2>Notes and possible features</h2>

<ul>
<li>Some data types are not supported yet. However, the main <em>useful</em> data types (integer, floating-point, and boolean) are supported.</li>
<li>FCDAs and ExtRefs cannot use the syntax <code>vector.mag.f</code> as values for data object or data attribute references.</li>
<li>Data types cannot contain arrays.</li>
<li>According to <a href="http://www.tissues.iec61850.com/tissue.mspx?issueid=579">the standard</a>, SV datasets should only contain primitive data types, and not constructed types. However, because SV encoding involves fixed-length value fields, it is always possible to reconstruct the data, if encoded and decoded consistently. Therefore, this library will allow constructed types to be encoded in SV packets. Semantically, SV datasets should only contain data values that have been sampled at the specified sampling rate. Again, for practicality, this library allows any DA or DO to be used in SV datasets.</li>
</ul>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/stevenblair">stevenblair</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-21122920-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>